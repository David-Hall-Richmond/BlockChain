const SHA256 = require('crypto-js/sha256');
const NodeRSA = require('node-rsa');
const fs = require('fs');


const file = fs.createWriteStream('./blockchain_output.txt');

/**
 * Block Class. Represents a single block with one transaction.
 */
class Block{

    /**
     * Basic block constructor
     * @param trans, a transaction generated by a Merchant
     * @param sequenceNum, the current sequence of the block in the overall chain
     * @param prevBlock, the last block in the chain
     */
    constructor(trans, sequenceNum, prevBlock){
            this.transaction = trans;
            this.sequenceNum = sequenceNum;
            if(prevBlock) {
                this.previousHash = prevBlock.calculateHash();
            }
            else{
                this.previousHash = 0;
            }
            this.minerSig = '';
            this.nonce = 0;
            this.miningTime = 0;

        //console.log(JSON.stringify(this,null,4));
    }

    /**
     * Calculates the hash of the current block
     * @returns {*}
     */
    calculateHash(){
        return SHA256(JSON.stringify(this.transaction.custPubKey) + JSON.stringify(this.transaction.merchPubKey)
            + this.transaction.date + this.transaction.amount.toString() + JSON.stringify(this.transaction.custSig)
            + JSON.stringify(this.transaction.merchSig) + this.sequenceNum.toString() );
    }
}

/**
 * Miner Class handles creating, adding, and managing blocks in the block chain
 */
class Miner{

    /**
     *
     * @param {number} diff The difficulty to mine the blocks
     */
    constructor(diff){
        this.key = new NodeRSA({b: 512});
        this.transQueue = [this.createGenesisBlock()];
        //console.log(this.transQueue.length);
        this.chain = [];
        this.difficulty = diff;
    }

    /**
     * Creates the first block in the chain
     * @returns {Block}
     */
    createGenesisBlock(){
        let newBlock = new Block(this.getBlankTrans(),0,null);
        newBlock.minerSig = this.signBlock(newBlock);
        return newBlock;
    }

    /**
     * Creates an empty transaction to add to the genesis block
     * @returns {Transaction}
     */
    getBlankTrans(){
        return new Transaction(0,0,0,0);
    }

    /**
     * returns the last Block in the chain
     * @returns {Block|*}
     */
    getLatestBlock(){
        //console.log(this.transQueue.length);
        return this.transQueue[this.transQueue.length-1];
    }

    /**
     * The mining method. Returns the nonce necessary to mine the block
     * @param block
     * @returns {number}
     */
    getNonce(block){
        let nonce = 0;
        let blockFieldString = block.custPubKey + block.merchPubKey + block.date + block.amount + block.custSig +
                                block.merchSig + block.sequenceNum;
        let diffCheck = Array(this.difficulty + 1).join("0");

        let mineStart = new Date();

        for(nonce;nonce<Number.MAX_SAFE_INTEGER;nonce++){
            let stringToHash = block.previousHash+nonce.toString()+blockFieldString;
            let hashedBlock=SHA256(stringToHash).toString();
            //console.log("Diff: " + this.difficulty + " Seq: " + block.sequenceNum + " nonce: " + nonce);
            /*if(nonce % 1000000 === 0){
                console.log(nonce);
            }*/
            if(hashedBlock.substring(0,this.difficulty) === diffCheck){
                console.log("Diff: " + this.difficulty + " Seq: " + block.sequenceNum + " nonce: " + nonce);
                let mineEnd = new Date();
                block.miningTime = mineEnd - mineStart;
                return nonce;
            }
        }
        console.log("Couldn't find nonce, if this prints its a bad thing")
    }

    /**
     * Adds a new transaction to the transaction queue
     * @param trans
     */
    addTransaction(trans){
        let prevBlock = this.getLatestBlock();
        //console.log(typeof prevBlock);
        const seqNum = prevBlock.sequenceNum + 1;
        let newBlock = new Block(trans,seqNum,prevBlock);
        newBlock.minerSig = this.signBlock(newBlock);
        this.transQueue.push(newBlock)
    }

    /**
     * Creates a blockchain from the transactions in the transaction queue
     * @param numToMine
     */
    mineBlocks(numToMine = this.transQueue.length){
        for(let i = 1;i<numToMine;i++){
            this.transQueue[i].nonce = this.getNonce(this.transQueue[i]);
            this.chain.push(this.transQueue[i]);
        }
    }

    /**
     * Prints info on the block that was mined
     * @param caseNum
     */
    printMiningInfo(caseNum){
        for(let i=0;i<this.chain.length;i++){
            file.write("Case: " + caseNum + " Block Number: " + this.chain[i].sequenceNum + " Nonces Attempted: "
            + this.chain[i].nonce + " Computation Time: " + this.chain[i].miningTime + "\n");
        }
    }


// code for 1st assignment
    /*
    isChainValid(){
        for(let i=1; i< this.chain.length;i++){
            const currentBlock = this.chain[i];
            const prevBlock = this.chain[i-1];

            if(!this.verifySign(currentBlock)){
                return false
            }
            const prevHashString = (currentBlock.previousHash).toString();
            const prevHashCalcString = prevBlock.calculateHash().toString();
            if(prevHashString !== prevHashCalcString){
               //console.log("............Failed checking current block previous hash against last block hash..............");
               //console.log(currentBlock.previousHash.toString());
               //console.log(prevBlock.calculateHash().toString());
               //console.log("Transaction " + i + " has been altered");
                file.write("............Failed checking current block previous hash against last block hash..............\n");
                file.write(currentBlock.previousHash.toString()+"\n");
                file.write(prevBlock.calculateHash().toString()+"\n");
                file.write("Transaction " + i + " has been altered\n");
                return false;
            }
        }
        return true;
    }

    printTransaction(i){
        console.log("Transaction number: " + i);
        console.log("Sequence Number: " + this.transQueue[i].sequenceNum);
        console.log("Customer public key:");
        console.log(this.transQueue[i].transaction.custPubKey);
        console.log("Merchant public key:");
        console.log(this.transQueue[i].transaction.merchPubKey + "\n");
        console.log("Date: " + this.transQueue[i].transaction.date);
        console.log("Amount: " + this.transQueue[i].transaction.amount);

        file.write("Transaction number: " + i +"\n");
        file.write("Customer public key:"+"\n");
        file.write(this.chain[i].transaction.custPubKey+"\n");
        file.write("Merchant public key:"+"\n");
        file.write(this.chain[i].transaction.merchPubKey + "\n");
        file.write("Date: " + this.chain[i].transaction.date+"\n");
        file.write("Amount: " + this.chain[i].transaction.amount+"\n");
    }

    printAllTransactions(){
        //console.log("Printing all transactions.........................................\n");
        file.write("Printing all transactions.........................................\n");
        for(let i=1;i<this.transQueue.length;i++){
            this.printTransaction(i);
        }
    }

    printByCustomer(customer){
        //console.log("Printing by customer.........................................\n");
        file.write("Printing by customer.........................................\n");
        for(let i=0;i<this.chain.length;i++){
            if(this.chain[i].transaction.custPubKey === customer.getPubKey())
                this.printTransaction(i);
        }
    }

    printByMerchant(merchant){
        //console.log("Printing by merchant.........................................\n");
        file.write("Printing by merchant.........................................\n");
        for(let i=0;i<this.chain.length;i++){
            if(this.chain[i].transaction.merchPubKey === merchant.getPubKey())
                this.printTransaction(i);
        }
    }*/

    signBlock(block){
        const sigString = block.merchSig + block.sequenceNum + block.previousHash;
        return this.key.sign(sigString);
    }

    verifySign(block){
        const sigString = block.merchSig + block.sequenceNum + block.previousHash
        return this.key.verify(sigString,block.minerSig);
    }

    getPubKey(){
        return this.key.exportKey('pkcs8-public');
    }
}

/**
 * Represents a Customer. The customer signs all transactions with the Merchant
 */
class Customer{

    /**
     * Basic constructor
     */
    constructor(){
        this.key = new NodeRSA({b:512});
    }

    /**
     * Signs the transaction using the Customer's private key
     * @param trans
     * @returns {string|Buffer}
     */
    signTrans(trans){
        const sigString = trans.custPubKey + trans.merchPubKey + trans.date + trans.amount;
        return this.key.sign(sigString);
    }

    /**
     * Returns the customer's public key
     * @returns {*}
     */
    getPubKey(){
        return this.key.exportKey('pkcs8-public');
    }
}

/**
 * Merchant class responsible for creating and signing each transaction
 */
class Merchant{

    /**
     * Customer constructor
     */
    constructor(){
        this.key = new NodeRSA({b:512});
    }

    /**
     * Signs the transaction using the Merchant's private key
     * @param trans
     * @returns {string|Buffer}
     */
    signTrans(trans){
        const sigString = trans.custPubKey + trans.merchPubKey + trans.date + trans.amount + trans.custSig;
        return this.key.sign(sigString);
    }

    /**
     * Returns the merchant's public key
     * @returns {*}
     */
    getPubKey(){
        return this.key.exportKey('pkcs8-public');
    }

    /**
     * Creates a new transaction
     * @param cust
     * @param date
     * @param amount
     * @param miner
     */
    newTransaction(cust,date,amount,miner){
        let trans = new Transaction(cust,this,date,amount);
        miner.addTransaction(trans);
    }
}

/**
 * Holds information for a single trnasaction
 */
class Transaction{

    /**
     * Creates a new Transaction instance. Calling with no customer indicates the need for a blank transaction
     * @param customer
     * @param merchant
     * @param date
     * @param amount
     */
    constructor(customer,merchant, date,amount){

        if(customer !==0) {
            this.custPubKey = customer.getPubKey();
            this.merchPubKey = merchant.getPubKey();
            this.date = date;
            this.amount = amount;
            this.custSig = customer.signTrans(this);
            this.merchSig = merchant.signTrans(this);
        }
        else {
            this.custPubKey = 0;
            this.merchPubKey = 0;
            this.date = 0;
            this.amount = 0;
            this.custSig = 0;
            this.merchSig = 0;
        }
        //console.log(JSON.stringify(this,null,4));
    }
}

/**
 * Returns a random integer between 0 and max
 * @param max
 * @returns {number}
 */
function getRandomInt(max){
    return Math.floor(Math.random() * max)+1;;
}

/**
 * returns a date with a random day, month, and year
 * @returns {string}
 */
function getRandomDate(){
    const month = getRandomInt(12).toString();
    let day = '';
    const year = (getRandomInt(70)+1950).toString();
    if(month in ["1","3","5","7","8","10","12"]){
        day = (getRandomInt(31)).toString();
    }
    else if(month === "2"){
        day = getRandomInt(28).toString();
    }
    else{
        day = getRandomInt(30).toString();
    }

    return month + "/" + day + "/" + year;
}

/**
 * Creates a random 2 decimal place number
 * @returns {string}
 */
function getRandomPrice(){
    const raw = Math.random()*3000 / 3;
    return raw.toFixed(2);
}

/**
 * Creates a set of random transactions
 * @param miner
 * @param customers
 * @param merchants
 */
function transactionGenerator(miner,customers,merchants){

    for(let i=0;i<customers.length;i++){
        for(let i=0;i<5;i++){
            let date = getRandomDate();
            let amount = getRandomPrice();
            let merch = merchants[getRandomInt(2)-1];
            merch.newTransaction(customers[i],date,amount,miner);
        }
    }
}

let miner0 = new Miner(0);
let miner5 = new Miner(5);
let miner6 = new Miner(6);

//let miner10 = new Miner(10);

let customers = [new Customer(),new Customer(),new Customer(),new Customer(),new Customer()];

let merchants = [new Merchant(), new Merchant()];


transactionGenerator(miner0,customers,merchants);
transactionGenerator(miner5,customers,merchants);
transactionGenerator(miner6,customers,merchants);

//transactionGenerator(miner10,customers,merchants);

miner0.mineBlocks();
miner0.printMiningInfo(0);
miner5.mineBlocks();
miner5.printMiningInfo(5);
miner6.mineBlocks();
miner6.printMiningInfo(6);

//miner10.mineBlocks(2);
//miner10.printMiningInfo(10);





/*miner0.printAllTransactions();
miner5.printAllTransactions();
miner10.printAllTransactions();*/

/*miner.printAllTransactions();
//console.log("--------------------------------------------------------------------------------------------------------");
file.write("--------------------------------------------------------------------------------------------------------"+"\n");
miner.printByCustomer(customers[2]);
//console.log("--------------------------------------------------------------------------------------------------------");
file.write("--------------------------------------------------------------------------------------------------------"+"\n");
miner.printByMerchant((merchants[1]));
//console.log("--------------------------------------------------------------------------------------------------------");
//console.log("Verifying the chain has not been tampered with: ");
//console.log((miner.isChainValid()) ? "The chain is unaltered" : "The chain has been altered");
file.write("--------------------------------------------------------------------------------------------------------"+"\n");
file.write("--------------------------------------------------------------------------------------------------------"+"\n");
file.write("Verifying the chain has not been tampered with: "+"\n");
file.write((miner.isChainValid()) ? "The chain is unaltered" : "The chain has been altered"+"\n");
file.write("--------------------------------------------------------------------------------------------------------"+"\n");

//console.log("Altering the chain...");
file.write("Altering the chain..."+"\n");
miner.chain[14].transaction.amount += 10;
//console.log("Verifying the chain has been tampered with: ");
//console.log((miner.isChainValid()) ? "The chain is unaltered" : "The chain has been altered");
file.write("Verifying the chain has been tampered with: "+"\n");
file.write((miner.isChainValid()) ? "The chain is unaltered" : "The chain has been altered"+"\n");
*/
process.on('exit', function(){
    file.end();
});